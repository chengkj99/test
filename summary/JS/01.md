# 你不知道的JS上(一) - 作用域和闭包

## 1 作用域

### 编译原理

在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。

##### 1.分词/词法分析(Tokenizing/Lexing)

这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块，这些代码块被称为词法单元(token)。

```js
var a = 2;
// 处理后
var、a、=、2 、;
```

> 分词(tokenizing)和词法分析(Lexing)之间的区别在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，有状态的解析规则是词法分析，无状态的是分词。

##### 2.解析/语法分析(Parsing)

这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。

##### 3.代码生成

将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。

简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。

### 理解作用域

如果要对程序 var a = 2; 进行处理，需要理解这个过程中的演员们：

##### 1.引擎

从头到尾负责整个 JavaScript 程序的编译及执行过程。

##### 2.编译器

引擎的好朋友之一，负责语法分析及代码生成等脏活累活。

##### 3.作用域

引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
为了能够完全理解 JavaScript 的工作原理，你需要开始像引擎(和它的朋友们)一样思考， 从它们的角度提出问题，并从它们的角度回答这些问题。

##### 协同工作

1. 首先，编译器将程序分解成词法单元，然后将词法单元解析成一个树结构；
1. 接下来引擎运行代码，遇到赋值等操作引擎会询问作用域，作用域启动 LHS 或 RHS 查询；
1. 然后，引擎和作用域之间不断合作，保证程序正常运行；
1. 最后，引擎运行结束。

### 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域(也就是全局作用域)为止。

作用域是一套规则，用于确定在何处以及如何查找变量(标识符)。

#### LHS 查询和 RHS 查询

赋值操作，当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。（如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询;
如果目的是获取变量的值，就会使用 RHS 查询。）

= 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。赋值操作符会导致 LHS 查询。

### 异常

- 如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。
- 如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。

## 2 词法作用域

我们将“作用域”定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。

作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域。另外一种叫作动态作用域，仍有一些编程语言在使用(比如 Bash 脚本、Perl 中的一些模式等)。JavaScript 所采用的作用域模型是词法作用域。

### 词法阶段

词法作用域就是定义在词法阶段的作用域。词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。

### 查找

作用域查找会在找到第一个匹配的标识符时停止。

在多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见 第一个匹配的标识符为止。

### 欺骗词法

如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修
改”(也可以说欺骗)词法作用域呢?

JavaScript 中有**两种机制**来实现这个目的。社区普遍认为在代码中使用这两种机制并不是什么好注意。但是关于它们的争论通常会忽略掉最重要的点: **欺骗词法作用域会导致性能下降。**

##### 1.eval

eval 可以在你写的代码中用程序生成代码并 运行，就好像代码是写在那个位置的一样。在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插 入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。

```js
function foo(str, a) {
  eval(str); // 欺骗!
  console.log(a, b);
}
var b = 2;
foo("var b = 3;", 1); // 1, 3
```

##### 2.with

JavaScript 中另一个难以掌握(并且现在也不推荐使用)的用来欺骗词法作用域的功能是 with 关键字。不推荐使用。

##### 3. 欺骗词法影响性能

eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。

如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。

不要使用它们。

## 3 函数作用域和块作用域

### 函数中的作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。

#### 隐藏内部实现

对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来 一些启示: 从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码「隐藏」起来了。

**实际的结果就是在这个代码片段的周围创建了一个作用域气泡**，也就是说这段代码中的任何声明(变量或函数)都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来「隐藏」它们。

为什么「隐藏」变量和函数是一个有用的技术?

大都是从最小特权原则中引申出来的，也叫**最小授权**或**最小暴露原则**。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都「隐藏」起来，比如某个模块或对象的 API 设计。

这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确 的代码应该是可以阻止对这些变量或函数进行访问的。

#### 规避冲突

「隐藏」作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

##### 1. 全局命名空间

变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它 们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

##### 2. 模块管理

另外一种避免冲突的办法和现代的**模块**机制很接近，就是从众多模块管理器中挑选一个来使用。就是从众多模块管理器(CommonJS、AMD、CMD)中挑选一个来使用。任何库都无需将标识符加入到全局作用域中，而是**通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中**。

这些工具并没有能够违反词法作用域规则的「神奇」功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中。

#### 函数作用域的问题

我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义「隐藏」起来，外部作用域无法访问包装函数内部的任何内容。

但是它会导致一些额外的问题。首先， **必须声明一个具名函数 foo()**，意味着 foo 这个名称本身「污染」了所在作用域。其次，**必须显式地通过函数名(foo())调用这个函数才能运行**其中的代码。如果函数不需要函数名(或者至少函数名可以不污染所在作用域)，并且能够自动运行，这将会更加理想。

解决方案是 IIFE：

```js
var a = 2;
(function foo() {
  var a = 3;
  console.log(a);
})();
console.log(a); // 2

// IIFE function 不污染外部作用域，不用调用便可执行
```

#### 函数声明和函数表达式

如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。也就是说，函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。

函数表达式可以是匿名的，而函数声明则不可以省略函数名。

```js
function() {} // 函数声明

(function(){})() // 函数表达式，因为开头是 (function...

const foo = function() {} // 函数表达式，因为开头是 const foo = ...

setTimeout(function(){}, 0) // 函数表达式，因为开头是 setTimeout(function(){}...
```

#### 匿名函数

匿名函数表达式书写起来简单快捷，但是有缺点：

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
3. 匿名函数省略了对于代码「可读性/可理解性」很重要的函数名。一个描述性的名称可以让代码不言自明。

总之：匿名函数：可读性差、调试困难，引用自身的问题

#### 立即执行函数表达式(IIFE: Immediately Invoked Function Expression)

```js
var a = 2;
(function foo() {
  var a = 3;
  console.log(a);
})();
console.log(a); // 2
```

由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 ( ) 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。

##### 用途

1.解决 undefined 标识符的默认值被错误覆盖导致的异常

```js
undefined = true; // 给其他代码挖了一个大坑!绝对不要这样做!
(function IIFE(undefined) {
  // 这可以保证在代码块中 undefined 标识符的值真的是 undefined
  var a;
  if (a === undefined) {
    console.log("Undefined is safe here!");
  }
})();
```

2.倒置代码的运行顺序

将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。这种模式在 UMD(Universal Module Definition)项目中被广泛使用。

```js
var a = 2;
(function IIFE(def) {
  def(window);
})(function def(golbal) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
});
```

### 块作用域

在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 i 会被绑定在外部作用域(函数或全局)中的事实。这就是块作用域的用处。变量的声明应该距离使用的地方越近越好，并最大限度地本地化。

```js
for (var i = 0; i < 10; i++) {
  console.log(i);
}
```

块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息 扩展为在块中隐藏信息。

#### 1 形成块作用域

- with
- try/catch
- let

#### 2 try/catch

JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。

```js
try {
  undefined(); // 执行一个非法操作来强制制造一个异常
} catch (err) {
  console.log(err); // 能够正常执行!
  console.log(err);
} // ReferenceError: err not found
```

正如你所看到的，err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。

> 尽管这个行为已经被标准化，并且被大部分的标准 JavaScript 环境(除了老 版本的 IE 浏览器)所支持，但是当同一个作用域中的两个或多个 catch 分句 用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。 实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部， 但是静态检查工具还是会很烦人地发出警告。为了避免这个不必要的警告，很多开发者会将 catch 的参数命名为 err1、 err2 等。也有开发者干脆关闭了静态检查工具对重复变量名的检查。

#### 3 let

ES6 引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。其有两个特性：块作用域和提升。

let 关键字可以将变量绑定到所在的任意作用域中(通常是 { .. } 内部)。

```js
var foo = true;
if (foo) {
  let bar = foo * 2;
  bar = something(bar);
  console.log(bar);
}
console.log(bar); // ReferenceError
```

**提升**是指声明会被视为存在于其所出现的作用域的整个范围内。使用 let 进行的声明不会在块作用域中进行提升。

```js
{
  console.log(bar); // ReferenceError! 声明的代码被运行之前，声明并不「存在」。
  let bar = 2;
}
```

一个 let 可以发挥优势的典型例子就是 for 循环。

```js
for (let i = 0; i < 10; i++) {
  console.log(i);
}
console.log(i); // ReferenceError

{
  let j;
  for (j = 0; j < 10; j++) {
    let i = j; // 每个迭代重新绑定!
    console.log(i);
  }
}
```

for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。

#### 4 垃圾收集

另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。

```js
function process(data) {
  // 在这里做点有趣的事情
}
var someReallyBigData = {};
process(someReallyBigData);
var btn = document.getElementById("my_button");
btn.addEventListener(
  "click",
  function click(evt) {
    console.log("button clicked");
  },
  /*capturingPhase=*/ false
);
```

click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构。

块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了:

```js
function process(data) {
  // 在这里做点有趣的事情
}
// 在这个块中定义的内容可以销毁了!
{
  let someReallyBigData = {};
  process(someReallyBigData);
}
var btn = document.getElementById("my_button");
btn.addEventListener(
  "click",
  function click(evt) {
    console.log("button clicked");
  },
  /*capturingPhase=*/ false
);
```

**为变量显式声明块作用域，并对变量进行本地绑定是非常有用的工具，可以把它添加到你的代码工具箱中了。**
**So good!!**

## 4 提升

所有的声明(变量和函数)都会被“移动”到各自作用域的 最顶端，这个过程被称为提升。

声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。

一个问题？到底是声明(蛋)在前，还是赋值(鸡)在前?

```js
a = 2;
var a;
console.log(a); // 2
```

很多开发者会认为是 undefined，因为 var a 声明在 a = 2 之后，他们自然而然地认为变量 被重新赋值了，因此会被赋予默认值 undefined。但是，真正的输出结果是 2。

```js
console.log(a);
var a = 2; // undefined
```

有的人会认为是 2，有的人会认为 ReferenceError 异常。结果是 undefined。

问题产生的原因是代码并不是一行一行执行的，在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。

因此，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。

当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个 声明: var a; 和 a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。

我们的第一个代码片段会以如下形式进行处理:

```js
var a;
a = 2;
console.log(a);
```

其中第一部分是编译，而第二部分是执行。
类似地，我们的第二个代码片段实际是按照以下流程处理的:

```js
var a;
console.log(a);
a = 2;
```

这个过程就好像变量和函数声明从它们在代码中出现的位置被「移动」到了最上面。这个过程就叫作**提升**。

### 函数优先

函数声明和变量声明都会被提升。函数会首先被提升，然后才是变量。

```js
foo(); // 1
var foo;
function foo() {
  console.log(1);
}
foo = function() {
  console.log(2);
};
```

会输出 1 而不是 2 !这个代码片段会被引擎理解为如下形式:

```js
function foo() {
  console.log(1);
}
foo(); // 1
foo = function() {
  console.log(2);
};
```

var foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前。

尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。

```js
foo(); // 3
function foo() {
  console.log(1);
}
var foo = function() {
  console.log(2);
};
function foo() {
  console.log(3);
}
```

一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代 码暗示的那样可以被条件判断所控制:

```js
foo(); // "b"
var a = true;
if (a) {
  function foo() {
    console.log("a");
  }
} else {
  function foo() {
    console.log("b");
  }
}
// 注意这个行为并不可靠，在 JavaScript 未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数。
```

> 要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题!

## 5 作用域闭包

### 代码案例理解闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

##### 案例 1

```js
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  bar();
}

foo(); // 2
```

这段代码看起来和嵌套作用域中的示例代码很相似。基于词法作用域的查找规则，函数 bar() 可以访问外部作用域中的变量 a(这个例子中的是一个 RHS 引用查询)。

这是闭包吗? 技术上来讲，**也许是**。但根据前面的定义，**确切地说并不是**。我认为最准确地用来解释 bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。(只是访问了作用域，但是并没有记住作用域)

##### 案例 2

```js
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  return bar;
}
var baz = foo();
baz(); // 2 —— 朋友，这就是闭包的效果。
```

函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在 foo() 执行后，其返回值(也就是内部的 bar() 函数)赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()。bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。

在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行**回收**。而闭包的「神奇」之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域? 原来是 bar() 本身在使用。

拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。

闭包使得函数可以继续访问定义时的词法作用域。

##### 案例 3

无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。

```js
function foo() {
  var a = 2;
  function baz() {
    console.log(a); // 2
  }
  bar(baz);
}
function bar(fn) {
  fn(); // 快看呀，这就是闭包!
}
```

把内部函数 baz 传递给 bar，当调用这个内部函数时(现在叫作 fn)，它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为它能够访问 a。

##### 案例 4

传递函数当然也可以是间接的。

```js
var fn;
function foo() {
  var a = 2;
  function baz() {
    console.log(a);
  }
  fn = baz; // 将 baz 分配给全局变量
}
function bar() {
  fn(); // 快看呀，这就是闭包!
}
foo();
bar(); // 2
```

**无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。**

##### 案例 5 setTimeut

```js
function wait(message) {
  setTimeout(function timer() {
    console.log(message);
  }, 1000);
}
wait("Hello, closure!");
```

将一个内部函数(名为 timer)传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。

wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..)作用域的闭包。

内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个 参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是 内部的 timer 函数，而词法作用域在这个过程中保持完整。**这就是闭包。**

##### 案例 6 Jquery

```js
function setupBot(name, selector) {
  $(selector).click(function activator() {
    console.log("Activating: " + name);
  });
}
setupBot("Closure Bot 1", "#bot_1");
setupBot("Closure Bot 2", "#bot_2");
```

本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。

在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使用了回调函数，实际上就是在使用闭包!

##### 案例 7 IIFE

通常认为 IIFE 是典型的闭包例子，但根据先前对闭包的定义，但并不一定是。

```js
var a = 2;
(function IIFE() {
  console.log(a);
})();
```

虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么? **因为函数(示例代码中的 IIFE)并不是在它本身的词法作用域以外执行的**。它在定义时所在的作用域中执行(而外部作用域，也就是全局作用域也持有 a)。a 是通过普通的词法作用域查找而非闭包被发现的。

尽管技术上来讲，闭包是发生在定义时的，但并不非常明显，就好像六祖慧能所说: 「既非风动，亦非幡动，仁者心动耳」(不是风动，也不是旗帜在动，动的只是自己的心。)。

尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。

### 循环和闭包

要说明闭包，for 循环是最常见的例子:

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 100);
}
// 6 6 6 6 6
```

正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。why？

首先解释 6 是从哪里来的。这个循环的终止条件是 i 不再 <=5。条件首次成立时 i 的值是 6。因此，输出显示的是循环结束时 i 的最终值。

延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。

缺陷是我们试图假设循环中的每个迭代在运行时都会给自己「捕获」一个 i 的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。

缺陷是什么? 我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。

##### 1 通过 IIFE 创建闭包作用域

我们可以通过创建闭包作用域解决吗？如 IIFE:

```js
for (var i = 1; i <= 5; i++) {
  (function() {
    setTimeout(function timer() {
      console.log(i);
    }, i * 1000);
  })();
}
```

这样不行。但是为什么呢?我们现在显然拥有更多的词法作用域了。的确每个延迟函数都会将 IIFE 在每次迭代中创建的作用域封闭起来。**如果作用域是空的**，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一个什么都没有的**空作用域**。它需要包含一点实质内容才能为我们所用。

它需要有自己的变量，用来在每个迭代中储存 i 的值:

```js
for (var i = 1; i <= 5; i++) {
  (function() {
    var j = i;
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })();
}

// 改进：

for (var i = 1; i <= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

**在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。**

##### 2 使用 let 创建块作用域

我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。前面 let 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。

本质上这是将一个块转换成一个可以被关闭的作用域。

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

## 7 模块

### 模块模式

还有其他的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一起来研究其中最强大的一个: 模块。

这是一段普通的代码，没有明显的闭包，只有两个私有数据变量 something 和 another，以及 doSomething() 和 doAnother() 两个内部函数，它们的词法作用域(而这就是闭包)也就是 foo() 的内部作用域。

```js
function foo() {
  var something = "cool";
  var another = [1, 2, 3];
  function doSomething() {
    console.log(something);
  }
  function doAnother() {
    console.log(another.join(" ! "));
  }
}
```

接下来考虑以下代码:

```js
function CoolModule() {
  var something = "cool";
  var another = [1, 2, 3];
  function doSomething() {
    console.log(something);
  }
  function doAnother() {
    console.log(another.join(" ! "));
  }
  return {
    doSomething: doSomething,
    doAnother: doAnother
  };
}
var foo = CoolModule();
foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。

> 从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函数。jQuery 就是一个很好的例子。jQuery 和 \$ 标识符就是 jQuery 模块的公共 API，但它们本身都是函数(由于函数也是对象，它们本身也可以拥有属性)。

##### 模块模式需要具备两个必要条件:

1. 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并 且可以访问或者修改私有的状态。

##### 单例模块

上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次， 每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实现单例模式:

```js
var foo = (function CoolModule() {
  var something = "cool";
  var another = [1, 2, 3];
  function doSomething() {
    console.log(something);
  }
  function doAnother() {
    console.log(another.join(" ! "));
  }
  return {
    doSomething: doSomething,
    doAnother: doAnother
  };
})();
foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

### 现代的模块机制

大多数模块依赖加载器/管理器本质上都是将这种模块定义封装进一个友好的 API。

```js
var MyModules = (function Manager() {
  var modules = {};
  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl, deps);
  }
  function get(name) {
    return modules[name];
  }

  return {
    define: define,
    get: get
  };
})();
```

这段代码的核心是 modules[name] = impl.apply(impl, deps)。为了模块的定义引入了包装函数(可以传入任何依赖)，并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。

下面展示了如何使用它来定义模块:

```js
MyModules.define("bar", [], function() {
  function hello(who) {
    return "Let me introduce: " + who;
  }
  return {
    hello: hello
  };
});
MyModules.define("foo", ["bar"], function(bar) {
  var hungry = "hippo";
  function awesome() {
    console.log(bar.hello(hungry).toUpperCase());
  }
  return {
    awesome: awesome
  };
});
var bar = MyModules.get("bar");
var foo = MyModules.get("foo");
console.log(bar.hello("hippo")); // Let me introduce: hippo
foo.awesome(); // LET ME INTRODUCE: HIPPO
```
"foo" 和 "bar" 模块都是通过一个返回公共 API 的函数来定义的。"foo" 甚至接受 "bar" 的示例作为依赖参数，并能相应地使用它。

它们符合前面列出的模块模式的两个特点: **为函数定义引入包装函数，并保证它的返回值和模块的 API 保持一致。**

### 未来的模块机制

ES6 中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6 会将文件当作独立的模块来处理。

> 基于函数的模块并不是一个能被稳定识别的模式(编译器无法识别)，它们 的 API 语义只有在运行时才会被考虑进来。因此可以在运行时修改一个模块 的 API。

import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上。module 会将整个模块的 API 导入并绑定到一个变量上。export 会将当前模块的一个标识符(变量、函数)导出为公共 API。这些操作可以在模块定义中根据需要使用任意多次。

> 相比之下，ES6 模块 API 更加稳定(API 不会在运行时改变)。由于编辑器知 道这一点，因此可以在(的确也这样做了)编译期检查对导入模块的 API 成 员的引用是否真实存在。如果 API 引用并不存在，编译器会在运行时抛出一 个或多个“早期”错误，而不会像往常一样在运行期采用动态的解决方案。


## 总结
以上涉及了以下知识点：
* 作用域: 作用域是一套规则，用于确定在何处以及如何查找变量(标识符)
* LHS查询和RHS查询: 如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询; 如果目的是获取变量的值，就会使用 RHS 查询。
* 词法作用域: 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。虽然可以，但是不要欺骗词法作用域，降低引擎运行 JS 性能。
* 函数作用域: 函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中「隐藏」起来。
* 块作用域: 块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常指 { .. } 内部)。
* 提升: 我们习惯将var a = 2; 看作一个声明，而实际上JavaScript 引擎将var a 和 a = 2 当作两个单独的声明，第一个是编译阶段，第二个是执行阶段。这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明(变量和函数)都会被「移动」到各自作用域的最顶端，这个过程被称为提升。
* 作用域闭包: 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。
* 模块: 模块有两个主要特征: (1)为创建内部作用域而调用了一个包装函数; (2)包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。
